section .data
    positive_msg db "The number is POSITIVE", 0
    negative_msg db "The number is NEGATIVE", 0
    zero_msg db "The number is ZERO", 0

section .bss
    number resb 4  ; Reserve space for input

section .text
    global _start

_start:
    ; Prompt user for input
    mov eax, 3       ; sys_read syscall
    mov ebx, 0       ; Read from stdin
    mov ecx, number  ; Buffer for input
    mov edx, 4       ; Maximum 4 bytes
    int 0x80         ; Interrupt

    ; Convert input from ASCII to integer
    mov ecx, number  ; Load input buffer address
    sub byte [ecx], '0' ; Convert first char to int (assumes single-digit input)
    mov al, [ecx]    ; Load the integer into AL
    cbw              ; Sign extend AL to AX

    ; Branching logic to classify the number
    cmp al, 0        ; Compare the number with 0
    je is_zero       ; Jump if equal to "ZERO"
    jl is_negative   ; Jump if less than "NEGATIVE"

    ; Positive case
    jmp is_positive  ; Unconditional jump to "POSITIVE"

is_positive:
    ; Display "POSITIVE"
    mov eax, 4       ; sys_write syscall
    mov ebx, 1       ; Write to stdout
    mov ecx, positive_msg ; Address of positive message
    mov edx, 22      ; Length of the message
    int 0x80         ; Interrupt
    jmp end          ; Unconditional jump to exit

is_negative:
    ; Display "NEGATIVE"
    mov eax, 4       ; sys_write syscall
    mov ebx, 1       ; Write to stdout
    mov ecx, negative_msg ; Address of negative message
    mov edx, 22      ; Length of the message
    int 0x80         ; Interrupt
    jmp end          ; Unconditional jump to exit

is_zero:
    ; Display "ZERO"
    mov eax, 4       ; sys_write syscall
    mov ebx, 1       ; Write to stdout
    mov ecx, zero_msg ; Address of zero message
    mov edx, 19      ; Length of the message
    int 0x80         ; Interrupt

end:
    ; Exit program
    mov eax, 1       ; sys_exit syscall
    xor ebx, ebx     ; Exit code 0
    int 0x80         ; Interrupt
// Comments explained in readme file
   
